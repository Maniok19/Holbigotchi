<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Muskrat Animation Viewer</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
            max-width: 250px;
        }
        #animationList {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        #animationList li {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #animationList li:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #animationList li.active {
            background: rgba(0, 150, 255, 0.5);
        }
        #questionModal {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            height: auto;
            background: none;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: flex-start;
        }
        #questionBox {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        #questionBox h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
        }
        .answer-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .answer-button:hover {
            background: #1976D2;
        }
        #feedbackMessage {
            margin-top: 10px;
            font-weight: bold;
            font-size: 14px;
        }
        .correct {
            color: #4CAF50;
        }
        .incorrect {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Muskrat Animations</h3>
            <ul id="animationList"></ul>
            <button id="playPause">Play</button>
            <button id="stop">Stop</button>
        </div>
    </div>

    <!-- Question Modal -->
    <div id="questionModal">
        <div id="questionBox">
            <h3>Feed your Muskrat!</h3>
            <p id="questionText"></p>
            <div id="answerButtons"></div>
            <div id="feedbackMessage"></div>
            <button id="closeModal" style="display: none; margin-top: 15px; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 8.0);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Add a simple ground plane to help visualize
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Variables for animation
        let mixer;
        let actions = {};
        let currentAction = null;
        const clock = new THREE.Clock();
        let model; // Store reference to the model
        let dogBowl; // Add reference to the dog bowl
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let lastPosition = new THREE.Vector3(); // Track previous position
        let isMoving = false;
        const maxSpeed = 0.02; // Maximum movement speed per frame
        const maxRotationSpeed = 0.05; // Maximum rotation speed per frame (radians)
        let targetRotation = 0; // Target Y rotation for smooth turning
        let idleStartTime = 0; // Track when idle state started
        const idleFaceDelay = 3000; // 3 seconds delay before facing screen
        let shouldFaceScreen = false;

        // Quiz questions for feeding
        const feedingQuestions = [
            {
                question: "1 + 1",
                answers: ["3", "2", "Insects only", "Tree bark"],
                correct: 1
            }
        ];

        let currentQuestion = null;
        let isQuestionActive = false;
        let isFeedingActive = false; // Add this flag
        let isManualAnimationActive = false; // Flag to prevent auto-animations from overriding manual ones

        // Load the dog bowl GLTF model
        function loadDogBowl() {
            const bowlLoader = new GLTFLoader();
            bowlLoader.load('./dog_bowl/DogBowlFBX.gltf', (gltf) => {
                dogBowl = gltf.scene;
                
                // Position the bowl in the center of the scene
                dogBowl.position.set(0, 0, 0);
                dogBowl.name = 'dogBowl'; // Name it for raycasting
                
                // Scale the bowl if needed (adjust as necessary)
                dogBowl.scale.set(1, 1, 1);
                
                // Enable shadows
                dogBowl.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(dogBowl);
                console.log('Dog bowl loaded successfully');
            }, (progress) => {
                console.log('Dog bowl loading progress:', progress);
            }, (error) => {
                console.error('Error loading dog bowl GLTF model:', error);
                // Fallback: create a simple bowl if the model fails to load
                createFallbackDogBowl();
            });
        }

        // Fallback function to create a simple bowl if GLTF loading fails
        function createFallbackDogBowl() {
            const bowlGroup = new THREE.Group();
            
            // Bowl base (cylinder)
            const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.1, 16);
            const bowlMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.y = 0.05;
            bowl.castShadow = true;
            bowl.receiveShadow = true;
            bowlGroup.add(bowl);
            
            // Bowl inner (slightly smaller cylinder for the inside)
            const innerGeometry = new THREE.CylinderGeometry(0.25, 0.18, 0.08, 16);
            const innerMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Darker brown
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.position.y = 0.09;
            bowlGroup.add(inner);
            
            // Food in the bowl (small sphere)
            const foodGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const foodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown food
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            food.position.y = 0.12;
            food.scale.y = 0.3; // Flatten it a bit
            bowlGroup.add(food);
            
            // Position the bowl in the center of the scene
            bowlGroup.position.set(0, 0, 0);
            bowlGroup.name = 'dogBowl'; // Name it for raycasting
            
            dogBowl = bowlGroup;
            scene.add(dogBowl);
            console.log('Fallback dog bowl created');
        }

        // Load the dog bowl
        loadDogBowl();

        // Function to show feeding question
        function showFeedingQuestion() {
            if (feedingQuestions.length === 0) return;
            
            isQuestionActive = true;
            isFeedingActive = true;
            
            // Select a random question
            currentQuestion = feedingQuestions[Math.floor(Math.random() * feedingQuestions.length)];
            
            // Update modal content
            document.getElementById('questionText').textContent = currentQuestion.question;
            
            // Clear previous buttons
            const answerButtons = document.getElementById('answerButtons');
            answerButtons.innerHTML = '';
            
            // Create answer buttons
            currentQuestion.answers.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = 'answer-button';
                button.onclick = () => checkAnswer(index);
                answerButtons.appendChild(button);
            });
            
            // Clear feedback and hide close button
            document.getElementById('feedbackMessage').innerHTML = '';
            document.getElementById('closeModal').style.display = 'none';
            
            // Show modal
            document.getElementById('questionModal').style.display = 'flex';
        }

        // Function to check answer
        function checkAnswer(selectedIndex) {
            const feedbackElement = document.getElementById('feedbackMessage');
            const closeButton = document.getElementById('closeModal');
            
            if (selectedIndex === currentQuestion.correct) {
                feedbackElement.innerHTML = '<span class="correct">Correct! Your muskrat is happy!</span>';
                // Play eating animation if available
                if (actions['Eat'] || actions['Eating']) {
                    const eatAction = actions['Eat'] || actions['Eating'];
                    playAnimationAuto(eatAction.getClip().name);
                }
            } else {
                feedbackElement.innerHTML = '<span class="incorrect">Wrong answer. Try again next time!</span>';
            }
            
            // Disable answer buttons
            const buttons = document.querySelectorAll('.answer-button');
            buttons.forEach(button => button.disabled = true);
            
            // Show close button
            closeButton.style.display = 'inline-block';
            closeButton.onclick = () => {
                document.getElementById('questionModal').style.display = 'none';
                isQuestionActive = false;
                isFeedingActive = false;
            };
        }

        // Load the GLTF model
        const loader = new GLTFLoader();
        loader.load('./moskrat/Muskrat.gltf', (gltf) => {
            model = gltf.scene; // Store the model reference
            scene.add(model);

            // Debug: Log model info
            console.log('Model loaded:', model);
            console.log('Animations found:', gltf.animations.length);

            // Get model bounds and scale appropriately
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            console.log('Model size:', size);
            console.log('Model center:', center);

            // Center the model
            model.position.sub(center);
            model.position.y = 0; // Place on ground

            // Calculate camera distance based on model size
            const maxDimension = Math.max(size.x, size.y, size.z);
            
            // Much closer camera positioning - divide by 30 to get much closer (3x zoom)
            const cameraDistance = maxDimension / 30; // 3x closer than before!
            
            // Position camera to view the model properly
            camera.position.set(cameraDistance * 2, cameraDistance * 1, cameraDistance * 3);
            camera.lookAt(0, 0, 0);
            
            console.log('Model max dimension:', maxDimension);
            console.log('Camera distance:', cameraDistance);

            // Setup animations
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                
                const animationList = document.getElementById('animationList');
                
                gltf.animations.forEach((clip, index) => {
                    const action = mixer.clipAction(clip);
                    actions[clip.name] = action;
                    
                    // Create list item for each animation
                    const li = document.createElement('li');
                    li.textContent = clip.name;
                    li.addEventListener('click', () => playAnimation(clip.name, li));
                    animationList.appendChild(li);
                });

                console.log('Animation actions created:', Object.keys(actions));
            } else {
                console.log('No animations found in the model');
            }
        }, (progress) => {
            console.log('Loading progress:', progress);
        }, (error) => {
            console.error('Error loading GLTF model:', error);
        });

        // Mouse movement tracking
        let lastMouseMoveTime = 0;
        let mouseMoving = false;
        const mouseStopDelay = 100; // milliseconds to wait before considering mouse stopped

        function onMouseMove(event) {
            // Convert mouse position to normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update mouse movement tracking
            lastMouseMoveTime = Date.now();
            mouseMoving = true;
            
            if (model) {
                // Create a ray from camera through mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Create a plane at ground level (y = 0) to intersect with
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                // Get intersection point with ground plane
                raycaster.ray.intersectPlane(groundPlane, intersectionPoint);
                
                if (intersectionPoint) {
                    // Calculate movement vector
                    const targetPosition = new THREE.Vector3(intersectionPoint.x, 0, intersectionPoint.z);
                    const movementVector = targetPosition.clone().sub(model.position);
                    
                    // Only move if there's a significant distance to the target
                    if (movementVector.length() > 0.05) {
                        // Limit movement speed
                        if (movementVector.length() > maxSpeed) {
                            movementVector.normalize().multiplyScalar(maxSpeed);
                        }
                        
                        // Store previous position
                        lastPosition.copy(model.position);
                        
                        // Apply movement
                        model.position.add(movementVector);
                        
                        // Calculate target rotation based on movement direction
                        const angle = Math.atan2(movementVector.x, movementVector.z);
                        targetRotation = angle;
                    }
                }
            }
        }

        // Add click event listener for the dog bowl
        function onMouseClick(event) {
            // Convert mouse position to normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster from camera through mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Check if we clicked on the dog bowl
            const intersects = raycaster.intersectObject(dogBowl, true);
            
            if (intersects.length > 0 && !isQuestionActive) {
                showFeedingQuestion();
            }
        }

        // Check mouse movement status in render loop
        function updateAnimationState() {
            // Don't change animations if feeding is active or manual animation is playing
            if (isFeedingActive || isManualAnimationActive) {
                return;
            }
            
            // Check if mouse has stopped moving
            if (Date.now() - lastMouseMoveTime > mouseStopDelay) {
                mouseMoving = false;
            }
            
            // Auto-play animations based on mouse movement
            if (mouseMoving && actions['Walk'] && currentAction !== actions['Walk']) {
                playAnimationAuto('Walk');
                shouldFaceScreen = false; // Reset face screen when moving
            } else if (!mouseMoving && actions['Idle_A'] && currentAction !== actions['Idle_A']) {
                playAnimationAuto('Idle_A');
                idleStartTime = Date.now(); // Record when idle started
                shouldFaceScreen = false; // Reset face screen flag
            }
            
            // Check if we should start facing the screen
            if (!mouseMoving && currentAction === actions['Idle_A']) {
                if (Date.now() - idleStartTime > idleFaceDelay && !shouldFaceScreen) {
                    shouldFaceScreen = true;
                    targetRotation = 0; // Face forward (towards screen)
                }
            }
        }

        // Function to smoothly rotate the model
        function updateModelRotation() {
            if (model) {
                // Get current Y rotation
                const currentRotation = model.rotation.y;
                
                // Calculate the shortest angular distance to target
                let rotationDiff = targetRotation - currentRotation;
                
                // Normalize rotation difference to [-PI, PI] range
                while (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
                while (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
                
                // Apply rotation speed limit (slower when facing screen for smoother transition)
                const rotSpeed = shouldFaceScreen ? maxRotationSpeed * 0.5 : maxRotationSpeed;
                if (Math.abs(rotationDiff) > rotSpeed) {
                    rotationDiff = Math.sign(rotationDiff) * rotSpeed;
                }
                
                // Apply the rotation
                model.rotation.y += rotationDiff;
            }
        }

        // Automatic animation function (doesn't update UI)
        function playAnimationAuto(animationName) {
            if (currentAction && actions[animationName]) {
                currentAction.fadeOut(0.2);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.2).play();
            }
        }

        // Animation control functions (manual control from UI)
        function playAnimation(animationName, listItem) {
            // Set manual animation flag to prevent auto-animations from overriding
            isManualAnimationActive = true;
            
            if (currentAction) {
                currentAction.fadeOut(0.3);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.3).play();
                
                // Update UI
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                listItem.classList.add('active');
                
                // Reset manual animation flag after the animation duration + fade time
                // Get animation duration and set timeout accordingly
                const animationDuration = currentAction.getClip().duration;
                setTimeout(() => {
                    isManualAnimationActive = false;
                }, (animationDuration + 0.3) * 1000); // Convert to milliseconds and add fade time
            }
        }

        // Control buttons
        document.getElementById('playPause').addEventListener('click', () => {
            if (currentAction) {
                if (currentAction.paused) {
                    currentAction.paused = false;
                    document.getElementById('playPause').textContent = 'Pause';
                } else {
                    currentAction.paused = true;
                    document.getElementById('playPause').textContent = 'Play';
                }
            }
        });

        document.getElementById('stop').addEventListener('click', () => {
            if (currentAction) {
                currentAction.stop();
                document.getElementById('playPause').textContent = 'Play';
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                
                // Reset manual animation flag when stopping
                isManualAnimationActive = false;
            }
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            
            // Update animation state based on mouse movement
            updateAnimationState();
            
            // Update model rotation smoothly
            updateModelRotation();
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Add mouse event listener
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick); // Add click listener

        // Remove the feed button functionality since we're using the bowl now
        /* 
        document.getElementById('feedButton').addEventListener('click', () => {
            if (!isQuestionActive) {
                showFeedingQuestion();
            }
        });
        */

        animate();
    </script>
</body>
</html>