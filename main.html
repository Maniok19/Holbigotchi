<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holbigotchi - Virtual Pet</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
            max-width: 250px;
        }
        #animalSelector {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }
        .animal-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            width: 70px;
        }
        .animal-button:hover { background: #1976D2; }
        .animal-button.active { background: #4CAF50; }
        #animationList {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        #animationList li {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #animationList li:hover { background: rgba(255, 255, 255, 0.2); }
        #animationList li.active { background: rgba(0, 150, 255, 0.5); }
        #questionModal {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: none;
            display: none;
            z-index: 1000;
        }
        #questionBox {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        #questionBox h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
        }
        .answer-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .answer-button:hover { background: #1976D2; }
        #feedbackMessage {
            margin-top: 10px;
            font-weight: bold;
            font-size: 14px;
        }
        .correct { color: #4CAF50; }
        .incorrect { color: #f44336; }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <div id="animalSelector">
                <h3>Choose Animal</h3>
                <button class="animal-button active" data-animal="muskrat">Muskrat</button>
                <button class="animal-button" data-animal="monkey">Monkey</button>
                <button class="animal-button" data-animal="gecko">Gecko</button>
            </div>
            <h3>Animations</h3>
            <ul id="animationList"></ul>
            <button id="playPause">Play</button>
            <button id="stop">Stop</button>
        </div>
    </div>

    <div id="questionModal">
        <div id="questionBox">
            <h3>Feed your Muskrat!</h3>
            <p id="questionText"></p>
            <div id="answerButtons"></div>
            <div id="feedbackMessage"></div>
            <button id="closeModal" style="display: none; margin-top: 15px; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Core application state
        class HolbigotchiApp {
            constructor() {
                this.initializeVariables();
                this.setupScene();
                this.setupLighting();
                this.createEnvironment();
                this.setupEventListeners();
                this.loadModels();
                this.initializeHungerSystem();
                this.animate();
            }

            initializeVariables() {
                // Scene components
                this.scene = new THREE.Scene();
                this.clock = new THREE.Clock();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                // Model and animation
                this.model = null;
                this.mixer = null;
                this.actions = {};
                this.currentAction = null;
                this.dogBowl = null;
                this.currentAnimal = 'muskrat';
                this.animalPaths = {
                    muskrat: './moskrat/Muskrat.gltf',
                    monkey: './Monkey/Colobus.gltf',
                    gecko: './Guecko/Gecko.gltf'
                };

                // Feeding system
                this.isQuestionActive = false;
                this.isFeedingActive = false;
                this.currentQuestion = null;
                this.feedingQuestions = [
                    // Basic questions
                    { question: "HTML ‚Äì Quelle balise est utilis√©e pour ins√©rer une image ?", answers: ["<img>", "<image>", "<pic>", "999"], correct: 0 },
                    { question: "CSS ‚Äì Que fait color: red; ?", answers: ["Change la couleur de fond en rouge", "Change la couleur du texte en rouge", "Change la couleur de la bordure en rouge"], correct: 1 },
                    { question: "JavaScript ‚Äì Que renvoie typeof null ?", answers: ["\"null\"", "\"object\"", "\"undefined\""], correct: 1 },
                    
                    // Intermediate questions
                    { question: "JavaScript (DOM) ‚Äì Comment s√©lectionne-t-on un √©l√©ment par son ID ?", answers: ["document.querySelectorAll(\"#id\")", "document.getElementByClassName(\"id\")", "document.getElementById(\"id\")"], correct: 2 },
                    { question: "Python (Flask) ‚Äì √Ä quoi sert render_template() dans Flask ?", answers: ["√Ä ex√©cuter une requ√™te SQL", "√Ä rendre un template HTML avec des donn√©es", "√Ä g√©n√©rer automatiquement un formulaire"], correct: 1 },
                    { question: "SQL ‚Äì Quel mot-cl√© SQL permet de supprimer une table ?", answers: ["REMOVE TABLE", "DELETE TABLE", "DROP TABLE"], correct: 2 },
                    
                    // Expert questions
                    { question: "JavaScript avanc√© ‚Äì Quelle est la sortie de ce code ?\nlet x = [1, 2, 3];\nconsole.log(typeof x);", answers: ["\"object\"", "\"array\"", "\"list\""], correct: 0 },
                    { question: "React ‚Äì Quel hook est utilis√© pour g√©rer un √©tat local ?", answers: ["useState()", "useEffect()", "useContext()"], correct: 0 },
                    { question: "API REST ‚Äì Quel code HTTP signifie \"Cr√©√© avec succ√®s\" ?", answers: ["201", "204", "400"], correct: 0 },
                    { question: "PostgreSQL ‚Äì Quelle clause permet de regrouper les r√©sultats ?", answers: ["GROUP BY", "MERGE INTO", "COLLATE BY"], correct: 0 }
                ];

                // Movement system
                this.isMoving = false;
                this.isManualAnimationActive = false;
                this.shouldFaceScreen = false;
                this.moveTarget = new THREE.Vector3();
                this.moveStartTime = 0;
                this.moveDuration = 0;
                this.nextMoveTime = Date.now() + 5000;
                this.idleStartTime = 0;
                this.moveSpeed = 0.02;
                this.moveRadius = 8;
                this.idleFaceDelay = 3000;

                // Interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Hunger system
                this.lastFeedTime = Date.now();
                this.hungerLevel = 0;
                this.isDead = false;
                this.hungerTimer = null;
                this.HUNGER_STAGES = { WELL_FED: 0, HUNGRY: 33.33, STARVING: 66.66, DEAD: 100 };
                this.HUNGER_INCREASE_RATE = 100 / (3 * 24 * 60 * 60); // 100% over 3 days
            }

            setupScene() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);

                // Create skybox
                const materialArray = this.createSkyboxMaterials();
                const skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);
                const skybox = new THREE.Mesh(skyboxGeo, materialArray);
                this.scene.add(skybox);
            }

            createSkyboxMaterials() {
                const textureLoader = new THREE.TextureLoader();
                const materialArray = [];
                const texturePaths = [
                    'skyBox/DaylightBox_Right.bmp', 'skyBox/DaylightBox_Left.bmp',
                    'skyBox/DaylightBox_Top.bmp', 'skyBox/DaylightBox_Bottom.bmp',
                    'skyBox/DaylightBox_Front.bmp', 'skyBox/DaylightBox_Back.bmp'
                ];
                
                texturePaths.forEach((path, index) => {
                    const texture = textureLoader.load(
                        path,
                        null,
                        null,
                        () => this.createGradientMaterial(index)
                    );
                    materialArray.push(new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
                });
                
                return materialArray;
            }

            createGradientMaterial(index) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const context = canvas.getContext('2d');
                const gradient = context.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#98D8E8');
                gradient.addColorStop(1, '#F0F8FF');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 512, 512);
                const texture = new THREE.CanvasTexture(canvas);
                return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
            }

            setupLighting() {
                // Ambient lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
                this.scene.add(ambientLight);

                // Main directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffeaa7, 2.0);
                directionalLight.position.set(10, 15, 5);
                directionalLight.castShadow = true;
                this.configureShadows(directionalLight);
                this.scene.add(directionalLight);

                // Fill and rim lights
                const fillLight = new THREE.DirectionalLight(0x74b9ff, 0.8);
                fillLight.position.set(-5, 8, -5);
                this.scene.add(fillLight);

                const rimLight = new THREE.DirectionalLight(0xffffff, 0.6);
                rimLight.position.set(-10, 5, -10);
                this.scene.add(rimLight);

                // Creature following light
                this.creatureLight = new THREE.PointLight(0xffffff, 0.8, 20);
                this.creatureLight.position.set(0, 3, 0);
                this.scene.add(this.creatureLight);

                // Hemisphere light for natural lighting
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x4a7c3c, 0.4);
                this.scene.add(hemisphereLight);
            }

            configureShadows(light) {
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                light.shadow.camera.near = 0.5;
                light.shadow.camera.far = 50;
                light.shadow.camera.left = -20;
                light.shadow.camera.right = 20;
                light.shadow.camera.top = 20;
                light.shadow.camera.bottom = -20;
            }

            createEnvironment() {
                this.createGround();
                this.createTrees();
                this.createRocks();
                this.createParticleEffects();
            }

            createGround() {
                const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4a7c3c, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }

            createTrees() {
                for (let i = 0; i < 20; i++) {
                    const x = (Math.random() - 0.5) * 150;
                    const z = (Math.random() - 0.5) * 150;
                    const distanceFromCenter = Math.sqrt(x * x + z * z);
                    
                    if (distanceFromCenter > 8) {
                        this.createTree(x, -0.5, z);
                    }
                }
            }

            createTree(x, y, z) {
                const treeGroup = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1.5;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Foliage
                const foliageGeometry = new THREE.SphereGeometry(2, 8, 6);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 4;
                foliage.scale.y = 0.8;
                foliage.castShadow = true;
                treeGroup.add(foliage);
                
                treeGroup.position.set(x, y, z);
                this.scene.add(treeGroup);
            }

            createRocks() {
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 100;
                    const z = (Math.random() - 0.5) * 100;
                    const distanceFromCenter = Math.sqrt(x * x + z * z);
                    
                    if (distanceFromCenter > 5) {
                        this.createRock(x, -0.3, z);
                    }
                }
            }

            createRock(x, y, z) {
                const rockGeometry = new THREE.DodecahedronGeometry(0.5 + Math.random());
                const rockMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(0.4, 0.4, 0.4).multiplyScalar(0.5 + Math.random() * 0.5)
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(x, y, z);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.castShadow = true;
                rock.receiveShadow = true;
                this.scene.add(rock);
            }

            createParticleEffects() {
                this.createVolumetricClouds();
                this.createFloatingParticles();
                this.createFloatingFood();
            }

            createVolumetricClouds() {
                const cloudGroup = new THREE.Group();
                
                for (let i = 0; i < 8; i++) {
                    const cloud = this.createSingleCloud();
                    cloud.position.set(
                        (Math.random() - 0.5) * 80,
                        15 + Math.random() * 10,
                        (Math.random() - 0.5) * 80
                    );
                    cloud.rotation.y = Math.random() * Math.PI * 2;
                    cloudGroup.add(cloud);
                }
                
                this.scene.add(cloudGroup);
                this.animateClouds(cloudGroup);
            }

            createSingleCloud() {
                const cloudGroup = new THREE.Group();
                const cloudParts = 8 + Math.random() * 6;
                
                for (let i = 0; i < cloudParts; i++) {
                    const radius = 3 + Math.random() * 4;
                    const cloudGeometry = new THREE.SphereGeometry(radius, 12, 8);
                    const cloudMaterial = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8 + Math.random() * 0.2,
                        fog: true
                    });
                    
                    const cloudSphere = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    const angle = (i / cloudParts) * Math.PI * 2;
                    const distance = Math.random() * 8;
                    
                    cloudSphere.position.set(
                        Math.cos(angle) * distance + (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 4,
                        Math.sin(angle) * distance + (Math.random() - 0.5) * 6
                    );
                    
                    const scale = 0.8 + Math.random() * 0.4;
                    cloudSphere.scale.set(scale, scale * 0.7, scale);
                    cloudGroup.add(cloudSphere);
                }
                
                return cloudGroup;
            }

            animateClouds(cloudGroup) {
                const animate = () => {
                    cloudGroup.rotation.y += 0.0003;
                    cloudGroup.children.forEach((cloud, index) => {
                        cloud.position.x += Math.sin(Date.now() * 0.0001 + index) * 0.01;
                        cloud.position.z += Math.cos(Date.now() * 0.0001 + index) * 0.01;
                    });
                    requestAnimationFrame(animate);
                };
                animate();
            }

            createFloatingParticles() {
                const particleCount = 80;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    // Positions
                    positions[i * 3] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 1] = Math.random() * 15 + 2;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                    
                    // Food-like colors
                    const foodType = Math.random();
                    if (foodType < 0.4) {
                        // Brown food pellets
                        colors[i * 3] = 0.6 + Math.random() * 0.3;
                        colors[i * 3 + 1] = 0.4 + Math.random() * 0.2;
                        colors[i * 3 + 2] = 0.2 + Math.random() * 0.1;
                    } else if (foodType < 0.7) {
                        // Golden kibble
                        colors[i * 3] = 1;
                        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                        colors[i * 3 + 2] = 0.3 + Math.random() * 0.2;
                    } else {
                        // Green veggie bits
                        colors[i * 3] = 0.2 + Math.random() * 0.3;
                        colors[i * 3 + 1] = 0.6 + Math.random() * 0.4;
                        colors[i * 3 + 2] = 0.1 + Math.random() * 0.2;
                    }
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.8,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                this.scene.add(particleSystem);
                this.animateParticles(particleSystem);
            }

            animateParticles(particleSystem) {
                const animate = () => {
                    const positions = particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(Date.now() * 0.001 + i) * 0.008;
                        positions[i] += Math.cos(Date.now() * 0.0008 + i) * 0.005;
                        positions[i + 1] -= 0.002;
                        
                        if (positions[i + 1] < -2) {
                            positions[i + 1] = 15 + Math.random() * 5;
                            positions[i] = (Math.random() - 0.5) * 100;
                            positions[i + 2] = (Math.random() - 0.5) * 100;
                        }
                    }
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animate);
                };
                animate();
            }

            createFloatingFood() {
                const foodGroup = new THREE.Group();
                
                for (let i = 0; i < 15; i++) {
                    const food = this.createFoodItem();
                    food.position.set(
                        (Math.random() - 0.5) * 80,
                        Math.random() * 12 + 3,
                        (Math.random() - 0.5) * 80
                    );
                    food.userData = {
                        initialY: food.position.y,
                        floatSpeed: 0.5 + Math.random() * 0.5,
                        fallSpeed: 0.001 + Math.random() * 0.001
                    };
                    foodGroup.add(food);
                }
                
                this.scene.add(foodGroup);
                this.animateFloatingFood(foodGroup);
            }

            createFoodItem() {
                const foodType = Math.random();
                let geometry, material, color;
                
                if (foodType < 0.4) {
                    geometry = new THREE.SphereGeometry(0.05, 6, 4);
                    color = new THREE.Color(0.6, 0.4, 0.2);
                } else if (foodType < 0.7) {
                    geometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                    color = new THREE.Color(0.8, 0.6, 0.3);
                } else {
                    geometry = new THREE.DodecahedronGeometry(0.04);
                    color = new THREE.Color(0.3, 0.7, 0.2);
                }
                
                material = new THREE.MeshLambertMaterial({ color });
                return new THREE.Mesh(geometry, material);
            }

            animateFloatingFood(foodGroup) {
                const animate = () => {
                    foodGroup.children.forEach((food, index) => {
                        food.position.y += Math.sin(Date.now() * 0.001 * food.userData.floatSpeed + index) * 0.01;
                        food.rotation.x += 0.01;
                        food.rotation.y += 0.005;
                        food.position.y -= food.userData.fallSpeed;
                        
                        if (food.position.y < -1) {
                            food.position.y = food.userData.initialY + Math.random() * 3;
                            food.position.x = (Math.random() - 0.5) * 80;
                            food.position.z = (Math.random() - 0.5) * 80;
                        }
                    });
                    requestAnimationFrame(animate);
                };
                animate();
            }

            loadModels() {
                this.loadMuskrat();
                this.loadDogBowl();
            }

            loadMuskrat() {
                const loader = new GLTFLoader();
                loader.load('./moskrat/Muskrat.gltf', (gltf) => {
                    this.model = gltf.scene;
                    this.scene.add(this.model);
                    this.setupModelProperties(gltf);
                    this.setupAnimations(gltf);
                    this.positionCamera();
                });
            }

            setupModelProperties(gltf) {
                this.model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        this.brightenMaterial(child.material);
                    }
                });

                // Position model on ground
                const box = new THREE.Box3().setFromObject(this.model);
                const center = box.getCenter(new THREE.Vector3());
                this.model.position.x -= center.x;
                this.model.position.z -= center.z;
                this.model.position.y = -box.min.y - 0.6;
            }

            brightenMaterial(material) {
                if (Array.isArray(material)) {
                    material.forEach(mat => {
                        if (mat.color) mat.color.multiplyScalar(1.5);
                        mat.needsUpdate = true;
                    });
                } else if (material.color) {
                    material.color.multiplyScalar(1.5);
                    material.needsUpdate = true;
                }
            }

            setupAnimations(gltf) {
                if (gltf.animations && gltf.animations.length > 0) {
                    this.mixer = new THREE.AnimationMixer(this.model);
                    const animationList = document.getElementById('animationList');
                    
                    gltf.animations.forEach((clip) => {
                        const action = this.mixer.clipAction(clip);
                        this.actions[clip.name] = action;
                        
                        const li = document.createElement('li');
                        li.textContent = clip.name;
                        li.addEventListener('click', () => this.playAnimation(clip.name, li));
                        animationList.appendChild(li);
                    });
                }
            }

            positionCamera() {
                const box = new THREE.Box3().setFromObject(this.model);
                const size = box.getSize(new THREE.Vector3());
                const maxDimension = Math.max(size.x, size.y, size.z);
                const cameraDistance = maxDimension / 30;
                
                this.camera.position.set(cameraDistance * 2, cameraDistance * 1, cameraDistance * 3);
                this.camera.lookAt(0, 0, 0);
                this.camera.far = 15000;
                this.camera.updateProjectionMatrix();
            }

            loadDogBowl() {
                const bowlLoader = new GLTFLoader();
                bowlLoader.load('./dog_bowl/DogBowlFBX.gltf', (gltf) => {
                    this.dogBowl = gltf.scene;
                    this.dogBowl.position.set(0, -0.57, 0);
                    this.dogBowl.name = 'dogBowl';
                    this.dogBowl.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    this.scene.add(this.dogBowl);
                }, null, () => this.createFallbackDogBowl());
            }

            createFallbackDogBowl() {
                const bowlGroup = new THREE.Group();
                
                const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.1, 16);
                const bowlMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
                bowl.position.y = 0.05;
                bowl.castShadow = true;
                bowl.receiveShadow = true;
                bowlGroup.add(bowl);
                
                bowlGroup.position.set(0, 0, 0);
                bowlGroup.name = 'dogBowl';
                this.dogBowl = bowlGroup;
                this.scene.add(this.dogBowl);
            }

            // Feeding system
            showFeedingQuestion() {
                if (this.feedingQuestions.length === 0) return;
                
                this.isQuestionActive = true;
                this.isFeedingActive = true;
                this.currentQuestion = this.feedingQuestions[Math.floor(Math.random() * this.feedingQuestions.length)];
                
                document.getElementById('questionText').textContent = this.currentQuestion.question;
                
                const answerButtons = document.getElementById('answerButtons');
                answerButtons.innerHTML = '';
                
                this.currentQuestion.answers.forEach((answer, index) => {
                    const button = document.createElement('button');
                    button.textContent = answer;
                    button.className = 'answer-button';
                    button.onclick = () => this.checkAnswer(index);
                    answerButtons.appendChild(button);
                });
                
                document.getElementById('feedbackMessage').innerHTML = '';
                document.getElementById('closeModal').style.display = 'none';
                document.getElementById('questionModal').style.display = 'flex';
            }

            checkAnswer(selectedIndex) {
                const feedbackElement = document.getElementById('feedbackMessage');
                const closeButton = document.getElementById('closeModal');
                
                if (selectedIndex === this.currentQuestion.correct) {
                    feedbackElement.innerHTML = '<span class="correct">Correct! Your muskrat is going to eat!</span>';
                    this.resetHunger();
                    setTimeout(() => this.makeEatAtBowl(), 1000);
                    this.createFoodFallEffect();
                    setTimeout(() => {
                        document.getElementById('questionModal').style.display = 'none';
                        this.isQuestionActive = false;
                        this.isFeedingActive = false;
                    }, 3000);
                } else {
                    feedbackElement.innerHTML = '<span class="incorrect">Wrong answer. Your muskrat is still hungry!</span>';
                    closeButton.style.display = 'inline-block';
                    closeButton.onclick = () => {
                        document.getElementById('questionModal').style.display = 'none';
                        this.isQuestionActive = false;
                        this.isFeedingActive = false;
                    };
                }
                
                document.querySelectorAll('.answer-button').forEach(button => button.disabled = true);
            }

            createFoodFallEffect() {
                const foodGroup = new THREE.Group();
                
                for (let i = 0; i < 50; i++) {
                    const food = this.createFoodItem();
                    const ringIndex = Math.floor(i / 10);
                    const angleInRing = (i % 10) / 10 * Math.PI * 2;
                    const ringRadius = 0.3 + (ringIndex * 0.2);
                    
                    food.position.set(
                        Math.cos(angleInRing) * ringRadius,
                        8 + Math.random() * 4 + ringIndex,
                        Math.sin(angleInRing) * ringRadius
                    );
                    
                    const targetRadius = Math.random() * 0.25;
                    const targetAngle = Math.random() * Math.PI * 2;
                    const layerHeight = Math.floor(i / 15) * 0.05;

                    food.userData = {
                        targetX: Math.cos(targetAngle) * targetRadius,
                        targetY: -0.35 + layerHeight,
                        targetZ: Math.sin(targetAngle) * targetRadius,
                        fallSpeed: 0.03 + Math.random() * 0.04,
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.3,
                            y: (Math.random() - 0.5) * 0.3,
                            z: (Math.random() - 0.5) * 0.3
                        }
                    };
                    
                    food.castShadow = true;
                    foodGroup.add(food);
                }
                
                this.scene.add(foodGroup);
                this.animateFoodFall(foodGroup);
            }

            animateFoodFall(foodGroup) {
                const animate = () => {
                    let allFoodLanded = true;
                    
                    foodGroup.children.forEach((food) => {
                        if (food.position.y > food.userData.targetY) {
                            allFoodLanded = false;
                            food.position.y -= food.userData.fallSpeed;
                            
                            const centerDirection = new THREE.Vector3(
                                food.userData.targetX - food.position.x,
                                0,
                                food.userData.targetZ - food.position.z
                            );
                            centerDirection.multiplyScalar(0.02);
                            food.position.add(centerDirection);
                            
                            food.rotation.x += food.userData.rotationSpeed.x;
                            food.rotation.y += food.userData.rotationSpeed.y;
                            food.rotation.z += food.userData.rotationSpeed.z;
                        } else {
                            food.position.y = food.userData.targetY;
                            food.position.x = food.userData.targetX;
                            food.position.z = food.userData.targetZ;
                            food.rotation.x = 0;
                            food.rotation.z = 0;
                        }
                    });
                    
                    if (!allFoodLanded) {
                        requestAnimationFrame(animate);
                    } else {
                        setTimeout(() => this.fadeOutFood(foodGroup), 5000);
                    }
                };
                animate();
            }

            fadeOutFood(foodGroup) {
                let opacity = 1;
                const fade = () => {
                    opacity -= 0.01;
                    foodGroup.children.forEach(food => {
                        if (food.material) {
                            food.material.transparent = true;
                            food.material.opacity = opacity;
                        }
                    });
                    
                    if (opacity > 0) {
                        requestAnimationFrame(fade);
                    } else {
                        this.scene.remove(foodGroup);
                    }
                };
                fade();
            }

            // Hunger system
            initializeHungerSystem() {
                this.createHungerBar();
                
                // Set initial hunger level to make creature almost starving (around 60-70%)
                const initialHungerLevel = 60 + Math.random() * 10; // Between 60-70%
                const timeToReachThisHunger = initialHungerLevel / this.HUNGER_INCREASE_RATE;
                this.lastFeedTime = Date.now() - (timeToReachThisHunger * 1000);
                this.hungerLevel = initialHungerLevel;
                
                // Update display immediately
                this.updateHungerDisplay(timeToReachThisHunger);
                this.updateHungerBehavior();
                
                this.hungerTimer = setInterval(() => this.updateHungerSystem(), 1000);
            }

createHungerBar() {
    const hungerBarHTML = `
        <div id="hungerBar" style="
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 300px; background: rgba(0, 0, 0, 0.8); padding: 15px;
            border-radius: 10px; color: white; font-family: Arial, sans-serif;
            z-index: 1000; border: 2px solid rgba(255, 255, 255, 0.2);
        ">
            <div style="text-align: center; margin-bottom: 8px; font-size: 14px; font-weight: bold;">
                <span id="hungerStatus">Well Fed</span>
            </div>
            <div style="width: 100%; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin-bottom: 8px;">
                <div id="hungerFill" style="
                    width: 100%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A);
                    transition: all 0.3s ease; border-radius: 10px;
                "></div>
            </div>
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #ccc;">
                <span>Dead</span><span>Starving</span><span>Hungry</span><span>Well Fed</span>
            </div>
            <div id="timeWithoutFood" style="text-align: center; margin-top: 5px; font-size: 12px; color: #aaa;">
                Last fed: just now
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="feedButton" style="
                    background: #4CAF50; color: white; border: none; padding: 8px 16px;
                    border-radius: 5px; cursor: pointer; font-size: 12px;
                ">Feed Muskrat</button>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', hungerBarHTML);
    document.getElementById('feedButton').addEventListener('click', () => {
        if (!this.isQuestionActive && !this.isDead) {
            this.showFeedingQuestion();
        }
    });
}

            updateHungerSystem() {
                if (this.isDead) return;
                
                const currentTime = Date.now();
                const timeSinceLastFeed = (currentTime - this.lastFeedTime) / 1000;
                this.hungerLevel = Math.min(100, timeSinceLastFeed * this.HUNGER_INCREASE_RATE);
                
                if (this.hungerLevel >= this.HUNGER_STAGES.DEAD) {
                    this.handleDeath();
                    return;
                }
                
                this.updateHungerDisplay(timeSinceLastFeed);
                this.updateHungerBehavior();
            }

updateHungerDisplay(timeSinceLastFeed) {
    const hungerFill = document.getElementById('hungerFill');
    const hungerStatus = document.getElementById('hungerStatus');
    const timeDisplay = document.getElementById('timeWithoutFood');
    
    if (hungerFill && hungerStatus && timeDisplay) {
        // Invert the bar - start at 100% and decrease as hunger increases
        const healthLevel = 100 - this.hungerLevel;
        hungerFill.style.width = `${healthLevel}%`;
        
        if (this.hungerLevel < this.HUNGER_STAGES.HUNGRY) {
            hungerFill.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
            hungerStatus.textContent = 'Well Fed';
            hungerStatus.style.color = '#4CAF50';
        } else if (this.hungerLevel < this.HUNGER_STAGES.STARVING) {
            hungerFill.style.background = 'linear-gradient(90deg, #FF9800, #FFC107)';
            hungerStatus.textContent = 'Hungry';
            hungerStatus.style.color = '#FF9800';
        } else {
            hungerFill.style.background = 'linear-gradient(90deg, #f44336, #E91E63)';
            hungerStatus.textContent = 'Starving!';
            hungerStatus.style.color = '#f44336';
        }
        
        const hours = Math.floor(timeSinceLastFeed / 3600);
        const minutes = Math.floor((timeSinceLastFeed % 3600) / 60);
        
        if (hours > 0) {
            timeDisplay.textContent = `Last fed: ${hours}h ${minutes}m ago`;
        } else if (minutes > 0) {
            timeDisplay.textContent = `Last fed: ${minutes}m ago`;
        } else {
            timeDisplay.textContent = 'Last fed: just now';
        }
    }
}

            handleDeath() {
                this.isDead = true;
                
                const hungerStatus = document.getElementById('hungerStatus');
                const timeDisplay = document.getElementById('timeWithoutFood');
                const hungerFill = document.getElementById('hungerFill');
                const feedButton = document.getElementById('feedButton');
                
                if (hungerStatus) {
                    hungerStatus.textContent = 'üíÄ DEAD';
                    hungerStatus.style.color = '#000';
                }
                if (timeDisplay) timeDisplay.textContent = 'Starved to death...';
                if (hungerFill) hungerFill.style.background = '#000';
                if (feedButton) {
                    feedButton.disabled = true;
                    feedButton.style.background = '#666';
                    feedButton.textContent = 'Dead';
                }
                
                const deathAnimation = this.actions['Death'] || this.actions['Sad'] || this.actions['Lying'];
                if (deathAnimation) {
                    this.playAnimationAuto(deathAnimation.getClip().name);
                }
                
                this.isMoving = false;
                this.isManualAnimationActive = true;
                
                setTimeout(() => {
                    alert('üíÄ Your muskrat has died from starvation! Refresh the page to start over.');
                }, 2000);
            }

            updateHungerBehavior() {
                if (this.isFeedingActive || this.isDead || this.isManualAnimationActive) return;
                
                this.moveSpeed = this.hungerLevel >= this.HUNGER_STAGES.HUNGRY ? 0.01 : 0.02;
                
                if (this.hungerLevel >= this.HUNGER_STAGES.HUNGRY && !this.isMoving) {
                    const sadChance = (this.hungerLevel / 100) * 0.003;
                    if (Math.random() < sadChance) {
                        const hungryAnimation = this.actions['Sad'] || this.actions['Idle_B'];
                        if (hungryAnimation) {
                            this.playAnimationAuto(hungryAnimation.getClip().name);
                        }
                    }
                }
            }

resetHunger() {
    if (this.isDead) return;
    
    this.lastFeedTime = Date.now();
    this.hungerLevel = 0;
    this.updateHungerDisplay(0);
    this.moveSpeed = 0.02;
    
    const hungerStatus = document.getElementById('hungerStatus');
    const hungerFill = document.getElementById('hungerFill');
    const feedButton = document.getElementById('feedButton');
    
    if (hungerStatus) {
        hungerStatus.textContent = 'Well Fed';
        hungerStatus.style.color = '#4CAF50';
    }
    if (hungerFill) {
        hungerFill.style.width = '100%'; // Full bar when well fed
        hungerFill.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
    }
    if (feedButton) {
        feedButton.disabled = false;
        feedButton.style.background = '#4CAF50';
        feedButton.textContent = 'Feed Muskrat';
    }
}

            // Movement and animation
            updateAnimationState() {
                if (this.isFeedingActive || this.isManualAnimationActive) return;
                
                const currentTime = Date.now();
                
                if (!this.isMoving && currentTime > this.nextMoveTime) {
                    this.startRandomMovement();
                }
                
                if (this.isMoving) {
                    this.updateMovement();
                    if (currentTime - this.moveStartTime > this.moveDuration) {
                        this.stopMovement();
                    }
                } else {
                    if (this.actions['Idle_A'] && this.currentAction !== this.actions['Idle_A']) {
                        this.playAnimationAuto('Idle_A');
                        this.idleStartTime = Date.now();
                        this.shouldFaceScreen = false;
                    }
                    
                    if (this.currentAction === this.actions['Idle_A']) {
                        if (Date.now() - this.idleStartTime > this.idleFaceDelay && !this.shouldFaceScreen) {
                            this.shouldFaceScreen = true;
                        }
                    }
                }
            }

            startRandomMovement() {
                if (!this.model) return;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.moveRadius;
                
                this.moveTarget.set(
                    Math.cos(angle) * distance,
                    this.model.position.y,
                    Math.sin(angle) * distance
                );
                
                this.isMoving = true;
                this.moveStartTime = Date.now();
                this.moveDuration = 2000 + Math.random() * 3000;
                this.nextMoveTime = this.moveStartTime + this.moveDuration + 5000 + Math.random() * 10000;
                
                const walkAction = this.actions['Walk'] || this.actions['Walking'] || this.actions['Run'] || this.actions['Running'];
                if (walkAction && this.currentAction !== walkAction) {
                    this.playAnimationAuto(walkAction.getClip().name);
                }
                
                this.shouldFaceScreen = false;
            }

            updateMovement() {
                if (!this.model || !this.isMoving) return;
                
                const direction = new THREE.Vector3();
                direction.subVectors(this.moveTarget, this.model.position);
                direction.y = 0;
                
                const distance = direction.length();
                
                if (distance > 0.1) {
                    direction.normalize();
                    this.model.position.add(direction.multiplyScalar(this.moveSpeed));
                    
                    this.creatureLight.position.set(
                        this.model.position.x,
                        this.model.position.y + 3,
                        this.model.position.z
                    );
                    
                    const targetRotation = Math.atan2(direction.x, direction.z);
                    this.model.rotation.y = targetRotation;
                } else {
                    this.stopMovement();
                }
            }

            stopMovement() {
                this.isMoving = false;
                
                if (this.actions['Idle_A'] && this.currentAction !== this.actions['Idle_A']) {
                    this.playAnimationAuto('Idle_A');
                    this.idleStartTime = Date.now();
                    this.shouldFaceScreen = false;
                }
            }

            startMovementToPosition(targetPosition) {
                if (!this.model) return;
                
                this.isMoving = false;
                this.moveTarget.copy(targetPosition);
                this.moveTarget.y = this.model.position.y;
                
                const distance = this.model.position.distanceTo(this.moveTarget);
                
                this.isMoving = true;
                this.moveStartTime = Date.now();
                this.moveDuration = (distance / this.moveSpeed) * 50;
                this.nextMoveTime = this.moveStartTime + this.moveDuration + 8000;
                
                const walkAction = this.actions['Walk'] || this.actions['Walking'] || this.actions['Run'] || this.actions['Running'];
                if (walkAction && this.currentAction !== walkAction) {
                    this.playAnimationAuto(walkAction.getClip().name);
                }
                
                if (distance > 0.1) {
                    const direction = new THREE.Vector3();
                    direction.subVectors(this.moveTarget, this.model.position);
                    direction.y = 0;
                    direction.normalize();
                    
                    const targetRotation = Math.atan2(direction.x, direction.z);
                    this.model.rotation.y = targetRotation;
                }
                
                this.shouldFaceScreen = false;
            }

            updateModelRotation() {
                if (this.model && this.shouldFaceScreen && !this.isMoving) {
                    const currentRotation = this.model.rotation.y;
                    const rotationDiff = -currentRotation;
                    const rotSpeed = 0.02;
                    
                    if (Math.abs(rotationDiff) > rotSpeed) {
                        this.model.rotation.y += Math.sign(rotationDiff) * rotSpeed;
                    } else {
                        this.model.rotation.y = 0;
                    }
                }
            }

            playAnimationAuto(animationName) {
                if (this.currentAction && this.actions[animationName]) {
                    this.currentAction.fadeOut(0.2);
                }
                
                this.currentAction = this.actions[animationName];
                if (this.currentAction) {
                    this.currentAction.reset().fadeIn(0.2).play();
                }
            }

        playAnimation(animationName, listItem) {
            this.isManualAnimationActive = true;
            
            if (this.isMoving) {
                this.stopMovement();
            }
            
            if (this.currentAction) {
                this.currentAction.fadeOut(0.3);
            }
            
            this.currentAction = this.actions[animationName];
            if (this.currentAction) {
                this.currentAction.reset().fadeIn(0.3).play();
                
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                listItem.classList.add('active');
                
                // Get the animation duration and add extra time for fade transitions
                const animationDuration = this.currentAction.getClip().duration;
                const totalTime = (animationDuration + 0.6) * 1000; // Add 0.6s for fade in/out
                
                // Disable the loop mode to ensure animation plays only once
                this.currentAction.setLoop(THREE.LoopOnce);
                this.currentAction.clampWhenFinished = true;
                
                // Set a timeout to re-enable automatic behavior after animation completes
                setTimeout(() => {
                    this.isManualAnimationActive = false;
                    // Reset to idle animation
                    if (this.actions['Idle_A']) {
                        this.playAnimationAuto('Idle_A');
                    }
                    // Clear the active state from UI
                    listItem.classList.remove('active');
                }, totalTime);
            }
        }

            makeEatAtBowl() {
                if (!this.model || this.isDead || !this.dogBowl) return;
                
                const bowlPosition = this.dogBowl.position.clone();
                const eatPosition = new THREE.Vector3(
                    bowlPosition.x + 0.5,
                    bowlPosition.y,
                    bowlPosition.z + 0.5
                );
                
                this.isMoving = false;
                this.isManualAnimationActive = true;
                this.moveTarget.copy(eatPosition);
                this.isMoving = true;
                this.moveStartTime = Date.now();
                this.moveDuration = 3000;
                
                const walkAction = this.actions['Walk'] || this.actions['Walking'] || this.actions['Run'] || this.actions['Running'];
                if (walkAction) {
                    this.playAnimationAuto(walkAction.getClip().name);
                }
                
                const moveToBowl = () => {
                    if (!this.isMoving) return;
                    
                    const direction = new THREE.Vector3();
                    direction.subVectors(this.moveTarget, this.model.position);
                    direction.y = 0;
                    
                    const distance = direction.length();
                    
                    if (distance > 0.3) {
                        direction.normalize();
                        this.model.position.add(direction.multiplyScalar(this.moveSpeed * 1.5));
                        
                        const rotationToTarget = Math.atan2(direction.x, direction.z);
                        this.model.rotation.y = rotationToTarget;
                        
                        requestAnimationFrame(moveToBowl);
                    } else {
                        this.startEatingAtBowl();
                    }
                };
                
                moveToBowl();
            }

            startEatingAtBowl() {
                this.isMoving = false;
                
                const bowlPosition = this.dogBowl.position.clone();
                const directionToBowl = new THREE.Vector3();
                directionToBowl.subVectors(bowlPosition, this.model.position);
                directionToBowl.y = 0;
                directionToBowl.normalize();
                
                const targetRotation = Math.atan2(directionToBowl.x, directionToBowl.z);
                
                const faceTheBowl = () => {
                    const currentRotation = this.model.rotation.y;
                    const rotationDiff = targetRotation - currentRotation;
                    let normalizedDiff = ((rotationDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    
                    const rotSpeed = 0.1;
                    if (Math.abs(normalizedDiff) > 0.05) {
                        this.model.rotation.y += Math.sign(normalizedDiff) * rotSpeed;
                        requestAnimationFrame(faceTheBowl);
                    } else {
                        this.model.rotation.y = targetRotation;
                        
                        const eatAction = this.actions['Eat'] || this.actions['Eating'] || this.actions['Idle_B'] || this.actions['Idle_A'];
                        if (eatAction) {
                            this.playAnimationAuto(eatAction.getClip().name);
                        }
                    }
                };
                
                faceTheBowl();
                
                setTimeout(() => {
                    this.isManualAnimationActive = false;
                    this.nextMoveTime = Date.now() + 3000;
                    
                    const happyAction = this.actions['Happy'] || this.actions['Joy'] || this.actions['Idle_A'];
                    if (happyAction) {
                        this.playAnimationAuto(happyAction.getClip().name);
                    }
                }, 4000);
            }

            // Event handlers
            setupEventListeners() {
                // Control buttons
                document.getElementById('playPause').addEventListener('click', () => {
                    if (this.currentAction) {
                        if (this.currentAction.paused) {
                            this.currentAction.paused = false;
                            document.getElementById('playPause').textContent = 'Pause';
                        } else {
                            this.currentAction.paused = true;
                            document.getElementById('playPause').textContent = 'Play';
                        }
                    }
                });

                document.getElementById('stop').addEventListener('click', () => {
                    if (this.currentAction) {
                        this.currentAction.stop();
                        document.getElementById('playPause').textContent = 'Play';
                        document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                        this.isManualAnimationActive = false;
                    }
                });

                // Animal selector
                document.querySelectorAll('.animal-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const selectedAnimal = button.getAttribute('data-animal');
                        this.loadAnimalModel(selectedAnimal);
                        
                        document.querySelectorAll('.animal-button').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                    });
                });

                // Click interaction
                window.addEventListener('click', (event) => this.onMouseClick(event));
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

// ...existing code...
            loadAnimalModel(animal) {
                if (this.model) {
                    this.scene.remove(this.model);
                    this.model = null;
                }
                
                // Clear current animations
                if (this.mixer) {
                    this.mixer.stopAllAction();
                    this.mixer = null;
                }
                this.actions = {};
                this.currentAction = null;
                
                // Clear animation list UI
                const animationList = document.getElementById('animationList');
                animationList.innerHTML = '';
                
                // Update current animal
                this.currentAnimal = animal;
                
                const loader = new GLTFLoader();
                // Use the correct path format based on your animalPaths object
                const modelPath = this.animalPaths[animal];
                
                loader.load(modelPath, (gltf) => {
                    this.model = gltf.scene;
                    this.scene.add(this.model);
                    this.setupModelProperties(gltf);
                    this.setupAnimations(gltf);
                    this.positionCamera();
                    
                    // Reset animation states
                    this.isManualAnimationActive = false;
                    this.isMoving = false;
                    this.shouldFaceScreen = false;
                    
                    // Update feed button text
                    const feedButton = document.getElementById('feedButton');
                    if (feedButton) {
                        const animalName = animal.charAt(0).toUpperCase() + animal.slice(1);
                        feedButton.textContent = `Feed ${animalName}`;
                    }
                    
                    // Update question modal title
                    const questionBox = document.querySelector('#questionBox h3');
                    if (questionBox) {
                        const animalName = animal.charAt(0).toUpperCase() + animal.slice(1);
                        questionBox.textContent = `Feed your ${animalName}!`;
                    }
                }, undefined, (error) => {
                    console.error('Error loading model:', error);
                    console.log('Attempted to load:', modelPath);
                });
            }
// ...existing code...

            onMouseClick(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check bowl click
                const bowlIntersects = this.raycaster.intersectObject(this.dogBowl, true);
                if (bowlIntersects.length > 0 && !this.isQuestionActive) {
                    this.showFeedingQuestion();
                    return;
                }
                
                // Ground click for movement
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0.5);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(groundPlane, intersectionPoint)) {
                    const clickDistance = Math.sqrt(intersectionPoint.x * intersectionPoint.x + intersectionPoint.z * intersectionPoint.z);
                    
                    if (clickDistance <= this.moveRadius) {
                        this.startMovementToPosition(intersectionPoint);
                    } else {
                        const direction = new THREE.Vector3(intersectionPoint.x, 0, intersectionPoint.z).normalize();
                        const limitedTarget = direction.multiplyScalar(this.moveRadius);
                        limitedTarget.y = 0;
                        this.startMovementToPosition(limitedTarget);
                    }
                }
            }

            // Main animation loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                if (this.mixer) this.mixer.update(delta);
                
                this.updateAnimationState();
                this.updateModelRotation();
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the application
        new HolbigotchiApp();
    </script>
</body>
</html>