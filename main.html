<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Muskrat Animation Viewer</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
            max-width: 250px;
        }
        #animationList {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        #animationList li {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #animationList li:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #animationList li.active {
            background: rgba(0, 150, 255, 0.5);
        }
        #questionModal {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            height: auto;
            background: none;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: flex-start;
        }
        #questionBox {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        #questionBox h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
        }
        .answer-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .answer-button:hover {
            background: #1976D2;
        }
        #feedbackMessage {
            margin-top: 10px;
            font-weight: bold;
            font-size: 14px;
        }
        .correct {
            color: #4CAF50;
        }
        .incorrect {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Muskrat Animations</h3>
            <ul id="animationList"></ul>
            <button id="playPause">Play</button>
            <button id="stop">Stop</button>
        </div>
    </div>

    <!-- Question Modal -->
    <div id="questionModal">
        <div id="questionBox">
            <h3>Feed your Muskrat!</h3>
            <p id="questionText"></p>
            <div id="answerButtons"></div>
            <div id="feedbackMessage"></div>
            <button id="closeModal" style="display: none; margin-top: 15px; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();

        // Replace the createMaterialArray function with this corrected version:
        function createMaterialArray() {
            console.log("🔍 Creating skybox materials...");
            
            const textureLoader = new THREE.TextureLoader();
            const materialArray = [];
            
            const texturePaths = [
                'skyBox/DaylightBox_Right.bmp',   // right - Note: capital B
                'skyBox/DaylightBox_Left.bmp',    // left  
                'skyBox/DaylightBox_Top.bmp',     // top
                'skyBox/DaylightBox_Bottom.bmp',  // bottom
                'skyBox/DaylightBox_Front.bmp',   // front
                'skyBox/DaylightBox_Back.bmp'     // back
            ];
            
            texturePaths.forEach((path, index) => {
                console.log(`📁 Attempting to load: ${path}`);
                
                const texture = textureLoader.load(
                    path,
                    (loadedTexture) => {
                        console.log(`✅ SUCCESS: Loaded ${path}`);
                        console.log(`   Size: ${loadedTexture.image.width}x${loadedTexture.image.height}`);
                    },
                    (progress) => {
                        console.log(`⏳ Loading ${path}: ${progress.loaded}/${progress.total}`);
                    },
                    (error) => {
                        console.error(`❌ FAILED: Could not load ${path}`);
                        console.error(`   Error:`, error);
                    }
                );
                
                materialArray.push(
                    new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.BackSide 
                    })
                );
            });
            
            console.log("📦 Created", materialArray.length, "materials");
            return materialArray;
        }

        // Create the skybox
        const materialArray = createMaterialArray();
        const skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);
        const skybox = new THREE.Mesh(skyboxGeo, materialArray);
        scene.add(skybox);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
        // Changed from 1000 to 15000 so camera can see the 10000x10000x10000 skybox

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 8.0);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Add a simple ground plane to help visualize
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Variables for animation
        let mixer;
        let actions = {};
        let currentAction = null;
        const clock = new THREE.Clock();
        let model; // Store reference to the model
        let dogBowl; // Add reference to the dog bowl
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        // Remove mouse tracking variables
        let idleStartTime = 0; // Track when idle state started
        const idleFaceDelay = 3000; // 3 seconds delay before facing screen
        let shouldFaceScreen = false;

        // Add random movement variables
        let isMoving = false;
        let moveTarget = new THREE.Vector3();
        let moveSpeed = 0.005;
        let nextMoveTime = 0;
        let moveDuration = 0;
        let moveStartTime = 0;
        const moveRadius = 3; // How far the creature can wander from center

        // Quiz questions for feeding
        const feedingQuestions = [
            {
                question: "1 + 1",
                answers: ["3", "2", "Insects only", "Tree bark"],
                correct: 1
            }
        ];

        let currentQuestion = null;
        let isQuestionActive = false;
        let isFeedingActive = false; // Add this flag
        let isManualAnimationActive = false; // Flag to prevent auto-animations from overriding manual ones

        // Load the dog bowl GLTF model
        function loadDogBowl() {
            const bowlLoader = new GLTFLoader();
            bowlLoader.load('./dog_bowl/DogBowlFBX.gltf', (gltf) => {
                dogBowl = gltf.scene;
                
                // Position the bowl in the center of the scene
                dogBowl.position.set(0, -0.5, 0);
                dogBowl.name = 'dogBowl'; // Name it for raycasting
                
                // Scale the bowl if needed (adjust as necessary)
                dogBowl.scale.set(1, 1, 1);
                
                // Enable shadows
                dogBowl.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(dogBowl);
                console.log('Dog bowl loaded successfully');
            }, (progress) => {
                console.log('Dog bowl loading progress:', progress);
            }, (error) => {
                console.error('Error loading dog bowl GLTF model:', error);
                // Fallback: create a simple bowl if the model fails to load
                createFallbackDogBowl();
            });
        }

        // Fallback function to create a simple bowl if GLTF loading fails
        function createFallbackDogBowl() {
            const bowlGroup = new THREE.Group();
            
            // Bowl base (cylinder)
            const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.1, 16);
            const bowlMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.y = 0.05;
            bowl.castShadow = true;
            bowl.receiveShadow = true;
            bowlGroup.add(bowl);
            
            // Bowl inner (slightly smaller cylinder for the inside)
            const innerGeometry = new THREE.CylinderGeometry(0.25, 0.18, 0.08, 16);
            const innerMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Darker brown
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.position.y = 0.09;
            bowlGroup.add(inner);
            
            // Food in the bowl (small sphere)
            const foodGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const foodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown food
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            food.position.y = 0.12;
            food.scale.y = 0.3; // Flatten it a bit
            bowlGroup.add(food);
            
            // Position the bowl in the center of the scene
            bowlGroup.position.set(0, 0, 0);
            bowlGroup.name = 'dogBowl'; // Name it for raycasting
            
            dogBowl = bowlGroup;
            scene.add(dogBowl);
            console.log('Fallback dog bowl created');
        }

        // Load the dog bowl
        loadDogBowl();

        // Function to show feeding question
        function showFeedingQuestion() {
            if (feedingQuestions.length === 0) return;
            
            isQuestionActive = true;
            isFeedingActive = true;
            
            // Select a random question
            currentQuestion = feedingQuestions[Math.floor(Math.random() * feedingQuestions.length)];
            
            // Update modal content
            document.getElementById('questionText').textContent = currentQuestion.question;
            
            // Clear previous buttons
            const answerButtons = document.getElementById('answerButtons');
            answerButtons.innerHTML = '';
            
            // Create answer buttons
            currentQuestion.answers.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = 'answer-button';
                button.onclick = () => checkAnswer(index);
                answerButtons.appendChild(button);
            });
            
            // Clear feedback and hide close button
            document.getElementById('feedbackMessage').innerHTML = '';
            document.getElementById('closeModal').style.display = 'none';
            
            // Show modal
            document.getElementById('questionModal').style.display = 'flex';
        }

        // Function to check answer
        function checkAnswer(selectedIndex) {
            const feedbackElement = document.getElementById('feedbackMessage');
            const closeButton = document.getElementById('closeModal');
            
            if (selectedIndex === currentQuestion.correct) {
                feedbackElement.innerHTML = '<span class="correct">Correct! Your muskrat is happy!</span>';
                // Play eating animation if available
                if (actions['Eat'] || actions['Eating']) {
                    const eatAction = actions['Eat'] || actions['Eating'];
                    playAnimationAuto(eatAction.getClip().name);
                }
            } else {
                feedbackElement.innerHTML = '<span class="incorrect">Wrong answer. Try again next time!</span>';
            }
            
            // Disable answer buttons
            const buttons = document.querySelectorAll('.answer-button');
            buttons.forEach(button => button.disabled = true);
            
            // Show close button
            closeButton.style.display = 'inline-block';
            closeButton.onclick = () => {
                document.getElementById('questionModal').style.display = 'none';
                isQuestionActive = false;
                isFeedingActive = false;
            };
        }

        // Load the GLTF model
        const loader = new GLTFLoader();
        loader.load('./Guecko/Gecko.gltf', (gltf) => {
            model = gltf.scene; // Store the model reference
            scene.add(model);

            // Debug: Log model info
            console.log('Model loaded:', model);
            console.log('Animations found:', gltf.animations.length);

            // Get model bounds and scale appropriately
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            console.log('Model size:', size);
            console.log('Model center:', center);

            // Center the model
            model.position.sub(center);
            model.position.y = 0; // Place on ground

            // Calculate camera distance based on model size
            const maxDimension = Math.max(size.x, size.y, size.z);

            // Much closer camera positioning - divide by 30 to get much closer (3x zoom)
            const cameraDistance = maxDimension / 30; // 3x closer than before!

            // Position camera to view the model properly AND see the skybox
            camera.position.set(cameraDistance * 2, cameraDistance * 1, cameraDistance * 3);
            camera.lookAt(0, 0, 0);

            // Make sure the camera can see the skybox
            camera.far = 15000; // Update far plane to see the skybox
            camera.updateProjectionMatrix();

            console.log('Model max dimension:', maxDimension);
            console.log('Camera distance:', cameraDistance);

            // Setup animations
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                
                const animationList = document.getElementById('animationList');
                
                gltf.animations.forEach((clip, index) => {
                    const action = mixer.clipAction(clip);
                    actions[clip.name] = action;
                    
                    // Create list item for each animation
                    const li = document.createElement('li');
                    li.textContent = clip.name;
                    li.addEventListener('click', () => playAnimation(clip.name, li));
                    animationList.appendChild(li);
                });

                console.log('Animation actions created:', Object.keys(actions));
            } else {
                console.log('No animations found in the model');
            }
        }, (progress) => {
            console.log('Loading progress:', progress);
        }, (error) => {
            console.error('Error loading GLTF model:', error);
        });

        // Add click event listener for the dog bowl only
        function onMouseClick(event) {
            // Convert mouse position to normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster from camera through mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Check if we clicked on the dog bowl
            const intersects = raycaster.intersectObject(dogBowl, true);
            
            if (intersects.length > 0 && !isQuestionActive) {
                showFeedingQuestion();
            }
        }

        // Remove updateAnimationState function - replace with enhanced version with movement
        function updateAnimationState() {
            // Don't change animations if feeding is active or manual animation is playing
            if (isFeedingActive || isManualAnimationActive) {
                return;
            }
            
            const currentTime = Date.now();
            
            // Handle random movement
            if (!isMoving && currentTime > nextMoveTime) {
                // Start a random movement
                startRandomMovement();
            }
            
            if (isMoving) {
                // Continue moving towards target
                updateMovement();
                
                // Check if movement duration is over
                if (currentTime - moveStartTime > moveDuration) {
                    stopMovement();
                }
            } else {
                // Auto-play idle animation if no manual animation is active
                if (actions['Idle_A'] && currentAction !== actions['Idle_A']) {
                    playAnimationAuto('Idle_A');
                    idleStartTime = Date.now();
                    shouldFaceScreen = false;
                }
                
                // Check if we should start facing the screen
                if (currentAction === actions['Idle_A']) {
                    if (Date.now() - idleStartTime > idleFaceDelay && !shouldFaceScreen) {
                        shouldFaceScreen = true;
                    }
                }
            }
        }

        // Add new movement functions
        function startRandomMovement() {
            if (!model) return;
            
            // Generate random target position within radius
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * moveRadius;
            
            moveTarget.set(
                Math.cos(angle) * distance,
                model.position.y, // Keep same Y position
                Math.sin(angle) * distance
            );
            
            // Set movement parameters
            isMoving = true;
            moveStartTime = Date.now();
            moveDuration = 2000 + Math.random() * 3000; // 2-5 seconds of movement
            
            // Schedule next movement (5-15 seconds after this one ends)
            nextMoveTime = moveStartTime + moveDuration + 5000 + Math.random() * 10000;
            
            // Start walking animation if available
            const walkAction = actions['Walk'] || actions['Walking'] || actions['Run'] || actions['Running'];
            if (walkAction && currentAction !== walkAction) {
                playAnimationAuto(walkAction.getClip().name);
            }
            
            // Face movement direction
            shouldFaceScreen = false;
            
            console.log('Starting movement to:', moveTarget);
        }

        function updateMovement() {
            if (!model || !isMoving) return;
            
            // Calculate direction to target
            const direction = new THREE.Vector3();
            direction.subVectors(moveTarget, model.position);
            direction.y = 0; // Keep movement on ground plane
            
            const distance = direction.length();
            
            if (distance > 0.1) {
                // Normalize direction and apply speed
                direction.normalize();
                
                // Move towards target
                model.position.add(direction.multiplyScalar(moveSpeed));
                
                // Rotate to face movement direction
                const targetRotation = Math.atan2(direction.x, direction.z);
                model.rotation.y = targetRotation;
            } else {
                // Reached target
                stopMovement();
            }
        }

        function stopMovement() {
            isMoving = false;
            
            // Return to idle animation
            if (actions['Idle_A'] && currentAction !== actions['Idle_A']) {
                playAnimationAuto('Idle_A');
                idleStartTime = Date.now();
                shouldFaceScreen = false;
            }
            
            console.log('Movement stopped');
        }

        // Remove updateModelRotation function - replace with enhanced version
        function updateModelRotation() {
            if (model && shouldFaceScreen && !isMoving) {
                // Smoothly rotate to face the screen (rotation y = 0)
                const currentRotation = model.rotation.y;
                const rotationDiff = -currentRotation; // Target is 0
                
                // Apply smooth rotation
                const rotSpeed = 0.02; // Slow rotation speed
                if (Math.abs(rotationDiff) > rotSpeed) {
                    model.rotation.y += Math.sign(rotationDiff) * rotSpeed;
                } else {
                    model.rotation.y = 0; // Snap to exact position when close enough
                }
            }
        }

        // Automatic animation function (doesn't update UI)
        function playAnimationAuto(animationName) {
            if (currentAction && actions[animationName]) {
                currentAction.fadeOut(0.2);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.2).play();
            }
        }

        // Animation control functions (manual control from UI)
        function playAnimation(animationName, listItem) {
            // Set manual animation flag to prevent auto-animations from overriding
            isManualAnimationActive = true;
            
            // Stop any current movement when manually controlling animations
            if (isMoving) {
                stopMovement();
            }
            
            if (currentAction) {
                currentAction.fadeOut(0.3);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.3).play();
                
                // Update UI
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                listItem.classList.add('active');
                
                // Reset manual animation flag after the animation duration + fade time
                // Get animation duration and set timeout accordingly
                const animationDuration = currentAction.getClip().duration;
                setTimeout(() => {
                    isManualAnimationActive = false;
                }, (animationDuration + 0.3) * 1000); // Convert to milliseconds and add fade time
            }
        }

        // Control buttons
        document.getElementById('playPause').addEventListener('click', () => {
            if (currentAction) {
                if (currentAction.paused) {
                    currentAction.paused = false;
                    document.getElementById('playPause').textContent = 'Pause';
                } else {
                    currentAction.paused = true;
                    document.getElementById('playPause').textContent = 'Play';
                }
            }
        });

        document.getElementById('stop').addEventListener('click', () => {
            if (currentAction) {
                currentAction.stop();
                document.getElementById('playPause').textContent = 'Play';
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                
                // Reset manual animation flag when stopping
                isManualAnimationActive = false;
            }
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            
            // Update animation state
            updateAnimationState();
            
            // Update model rotation for screen facing
            updateModelRotation();
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Remove mouse move listener, keep only click listener for dog bowl interaction
        window.addEventListener('click', onMouseClick);

        animate();
    </script>
</body>
</html>
