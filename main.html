<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Muskrat Animation Viewer</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
            max-width: 250px;
        }
        #animationList {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        #animationList li {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #animationList li:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #animationList li.active {
            background: rgba(0, 150, 255, 0.5);
        }
        #questionModal {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            height: auto;
            background: none;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: flex-start;
        }
        #questionBox {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        #questionBox h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
        }
        .answer-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .answer-button:hover {
            background: #1976D2;
        }
        #feedbackMessage {
            margin-top: 10px;
            font-weight: bold;
            font-size: 14px;
        }
        .correct {
            color: #4CAF50;
        }
        .incorrect {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Muskrat Animations</h3>
            <ul id="animationList"></ul>
            <button id="playPause">Play</button>
            <button id="stop">Stop</button>
        </div>
    </div>

    <!-- Question Modal -->
    <div id="questionModal">
        <div id="questionBox">
            <h3>Feed your Muskrat!</h3>
            <p id="questionText"></p>
            <div id="answerButtons"></div>
            <div id="feedbackMessage"></div>
            <button id="closeModal" style="display: none; margin-top: 15px; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();

        // Add missing variable declarations
        const clock = new THREE.Clock();
        let model = null;
        let mixer = null;
        let actions = {};
        let currentAction = null;
        let dogBowl = null;

        // Variables for feeding system
        let isQuestionActive = false;
        let isFeedingActive = false;
        let currentQuestion = null;

        // Variables for movement system
        let isMoving = false;
        let isManualAnimationActive = false;
        let shouldFaceScreen = false;
        let moveTarget = new THREE.Vector3();
        let moveStartTime = 0;
        let moveDuration = 0;
        let nextMoveTime = Date.now() + 5000; // Start first movement after 5 seconds
        let idleStartTime = 0;
        const moveSpeed = 0.02;
        const moveRadius = 8;
        const idleFaceDelay = 3000; // 3 seconds

        // Variables for raycasting (bowl interaction)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Feeding questions array
        const feedingQuestions = [
            {
                question: "1+2",
                answers: ["2", "3", "4", "999"],
                correct: 0
            }
        ];

        // Replace the createMaterialArray function with this corrected version:
        function createMaterialArray() {
            console.log("üîç Creating skybox materials...");
            
            const textureLoader = new THREE.TextureLoader();
            const materialArray = [];
            
            // Try beautiful nature skybox first, fallback to your current one
            const texturePaths = [
                'skyBox/DaylightBox_Right.bmp',   // right
                'skyBox/DaylightBox_Left.bmp',    // left  
                'skyBox/DaylightBox_Top.bmp',     // top
                'skyBox/DaylightBox_Bottom.bmp',  // bottom
                'skyBox/DaylightBox_Front.bmp',   // front
                'skyBox/DaylightBox_Back.bmp'     // back
            ];
            
            texturePaths.forEach((path, index) => {
                console.log(`üìÅ Attempting to load: ${path}`);
                
                const texture = textureLoader.load(
                    path,
                    (loadedTexture) => {
                        console.log(`‚úÖ SUCCESS: Loaded ${path}`);
                        console.log(`   Size: ${loadedTexture.image.width}x${loadedTexture.image.height}`);
                    },
                    (progress) => {
                        console.log(`‚è≥ Loading ${path}: ${progress.loaded}/${progress.total}`);
                    },
                    (error) => {
                        console.error(`‚ùå FAILED: Could not load ${path}`);
                        console.error(`   Error:`, error);
                        // Fallback to gradient if texture fails
                        createGradientMaterial(index);
                    }
                );
                
                materialArray.push(
                    new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.BackSide 
                    })
                );
            });
            
            console.log("üì¶ Created", materialArray.length, "materials");
            return materialArray;
        }

        // Add beautiful gradient fallback for skybox
        function createGradientMaterial(index) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Create beautiful sky gradient
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.5, '#98D8E8'); // Light blue
            gradient.addColorStop(1, '#F0F8FF'); // Alice blue
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.BackSide 
            });
        }

        // Create the skybox
        const materialArray = createMaterialArray();
        const skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);
        const skybox = new THREE.Mesh(skyboxGeo, materialArray);
        scene.add(skybox);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
        // Changed from 1000 to 15000 so camera can see the 10000x10000x10000 skybox

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Reduced ambient
        scene.add(ambientLight);

        // Main directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffeaa7, 1.2); // Warm sunlight
        directionalLight.position.set(10, 15, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Add fill light for softer shadows
        const fillLight = new THREE.DirectionalLight(0x74b9ff, 0.3); // Cool fill light
        fillLight.position.set(-5, 8, -5);
        scene.add(fillLight);

        // Add atmospheric fog for depth
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        // Add a simple ground plane to help visualize
        function createBeautifulGround() {
            // Create a larger, more detailed ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Add some height variation for terrain
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 0.5 - 0.25; // Random height variation
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            
            // Create a grass-like material
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a7c3c, // Forest green
                transparent: true,
                opacity: 0.9
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add some decorative elements
            addEnvironmentDetails();
        }

        // Add beautiful environment details
        function addEnvironmentDetails() {
            // Add some trees/bushes
            for (let i = 0; i < 20; i++) {
                createTree(
                    (Math.random() - 0.5) * 150, // Random X position
                    -0.5, // Ground level
                    (Math.random() - 0.5) * 150  // Random Z position
                );
            }
            
            // Add some rocks
            for (let i = 0; i < 15; i++) {
                createRock(
                    (Math.random() - 0.5) * 100,
                    -0.3,
                    (Math.random() - 0.5) * 100
                );
            }
            
            // Add floating particles for ambiance
            createFloatingParticles();
        }

        // Create simple trees
        function createTree(x, y, z) {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // Tree foliage
            const foliageGeometry = new THREE.SphereGeometry(2, 8, 6);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 4;
            foliage.scale.y = 0.8;
            foliage.castShadow = true;
            treeGroup.add(foliage);
            
            treeGroup.position.set(x, y, z);
            
            // Don't place trees too close to the center (where the pet is)
            const distanceFromCenter = Math.sqrt(x * x + z * z);
            if (distanceFromCenter > 8) {
                scene.add(treeGroup);
            }
        }

        // Create decorative rocks
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5 + Math.random());
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color(0.4, 0.4, 0.4).multiplyScalar(0.5 + Math.random() * 0.5)
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, y, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            // Don't place rocks too close to the center
            const distanceFromCenter = Math.sqrt(x * x + z * z);
            if (distanceFromCenter > 5) {
                scene.add(rock);
            }
        }

        // Create floating particles for magical ambiance
        function createFloatingParticles() {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Positions
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 20 + 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                // Colors (soft golden particles)
                colors[i * 3] = 1; // R
                colors[i * 3 + 1] = 0.8; // G
                colors[i * 3 + 2] = 0.4; // B
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // Animate particles
            function animateParticles() {
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        // Load the dog bowl GLTF model
        function loadDogBowl() {
            const bowlLoader = new GLTFLoader();
            bowlLoader.load('./dog_bowl/DogBowlFBX.gltf', (gltf) => {
                dogBowl = gltf.scene;
                
                // Position the bowl in the center of the scene
                dogBowl.position.set(0, -0.5, 0);
                dogBowl.name = 'dogBowl'; // Name it for raycasting
                
                // Scale the bowl if needed (adjust as necessary)
                dogBowl.scale.set(1, 1, 1);
                
                // Enable shadows
                dogBowl.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(dogBowl);
                console.log('Dog bowl loaded successfully');
            }, (progress) => {
                console.log('Dog bowl loading progress:', progress);
            }, (error) => {
                console.error('Error loading dog bowl GLTF model:', error);
                // Fallback: create a simple bowl if the model fails to load
                createFallbackDogBowl();
            });
        }

        // Fallback function to create a simple bowl if GLTF loading fails
        function createFallbackDogBowl() {
            const bowlGroup = new THREE.Group();
            
            // Bowl base (cylinder)
            const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.1, 16);
            const bowlMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.y = 0.05;
            bowl.castShadow = true;
            bowl.receiveShadow = true;
            bowlGroup.add(bowl);
            
            // Bowl inner (slightly smaller cylinder for the inside)
            const innerGeometry = new THREE.CylinderGeometry(0.25, 0.18, 0.08, 16);
            const innerMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Darker brown
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.position.y = 0.09;
            bowlGroup.add(inner);
            
            // Food in the bowl (small sphere)
            const foodGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const foodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown food
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            food.position.y = 0.12;
            food.scale.y = 0.3; // Flatten it a bit
            bowlGroup.add(food);
            
            // Position the bowl in the center of the scene
            bowlGroup.position.set(0, 0, 0);
            bowlGroup.name = 'dogBowl'; // Name it for raycasting
            
            dogBowl = bowlGroup;
            scene.add(dogBowl);
            console.log('Fallback dog bowl created');
        }

        // Function to show feeding question
        function showFeedingQuestion() {
            if (feedingQuestions.length === 0) return;
            
            isQuestionActive = true;
            isFeedingActive = true;
            
            // Select a random question
            currentQuestion = feedingQuestions[Math.floor(Math.random() * feedingQuestions.length)];
            
            // Update modal content
            document.getElementById('questionText').textContent = currentQuestion.question;
            
            // Clear previous buttons
            const answerButtons = document.getElementById('answerButtons');
            answerButtons.innerHTML = '';
            
            // Create answer buttons
            currentQuestion.answers.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = 'answer-button';
                button.onclick = () => checkAnswer(index);
                answerButtons.appendChild(button);
            });
            
            // Clear feedback and hide close button
            document.getElementById('feedbackMessage').innerHTML = '';
            document.getElementById('closeModal').style.display = 'none';
            
            // Show modal
            document.getElementById('questionModal').style.display = 'flex';
        }

        // Add these variables after the other variable declarations (around line 115)
        let foodParticles = [];
        let isDroppingFood = false;

        // Add this function to create and animate falling food particles
        function createFallingFood() {
            if (isDroppingFood || !dogBowl) return;
            
            isDroppingFood = true;
            
            // Create multiple food particles
            const particleCount = 15;
            foodParticles = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Create food particle (small sphere)
                const foodGeometry = new THREE.SphereGeometry(0.05, 8, 6);
                const foodMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.8, 0.5) // Brown variations
                });
                const foodParticle = new THREE.Mesh(foodGeometry, foodMaterial);
                
                // Start position above the bowl
                foodParticle.position.set(
                    dogBowl.position.x + (Math.random() - 0.5) * 0.5, // Random X around bowl
                    dogBowl.position.y + 3 + Math.random() * 0.5,      // Start high above bowl
                    dogBowl.position.z + (Math.random() - 0.5) * 0.5   // Random Z around bowl
                );
                
                // Add physics properties
                foodParticle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02, // Small random horizontal velocity
                        0,                              // No initial Y velocity (will fall)
                        (Math.random() - 0.5) * 0.02   // Small random horizontal velocity
                    ),
                    gravity: -0.001,                    // Gravity acceleration
                    bounced: false,                     // Track if particle has bounced
                    life: 1.0                          // Life span for fade out
                };
                
                foodParticle.castShadow = true;
                scene.add(foodParticle);
                foodParticles.push(foodParticle);
            }
            
            console.log('Started dropping food particles:', particleCount);
        }

        // Add this function to update falling food animation
        function updateFallingFood() {
            if (foodParticles.length === 0) {
                isDroppingFood = false;
                return;
            }
            
            const particlesToRemove = [];
            
            foodParticles.forEach((particle, index) => {
                const userData = particle.userData;
                
                // Apply gravity
                userData.velocity.y += userData.gravity;
                
                // Update position
                particle.position.add(userData.velocity);
                
                // Check if particle hit the ground/bowl level
                const bowlY = dogBowl.position.y + 0.1; // Slightly above bowl bottom
                if (particle.position.y <= bowlY && !userData.bounced) {
                    // Bounce once
                    userData.velocity.y = Math.abs(userData.velocity.y) * 0.3; // Reduce bounce
                    userData.velocity.x *= 0.7; // Reduce horizontal velocity
                    userData.velocity.z *= 0.7;
                    userData.bounced = true;
                    particle.position.y = bowlY; // Snap to bowl level
                }
                
                // If particle has bounced and is settling
                if (userData.bounced && Math.abs(userData.velocity.y) < 0.001) {
                    userData.velocity.multiplyScalar(0.9); // Slow down
                    
                    // Start fading out after settling
                    userData.life -= 0.01;
                    if (userData.life <= 0) {
                        particlesToRemove.push(index);
                    } else {
                        // Fade out the particle
                        particle.material.opacity = userData.life;
                        particle.material.transparent = true;
                    }
                }
                
                // Remove particles that fall too far or live too long
                if (particle.position.y < -2 || userData.life <= 0) {
                    particlesToRemove.push(index);
                }
            });
            
            // Remove finished particles
            particlesToRemove.reverse().forEach(index => {
                const particle = foodParticles[index];
                scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
                foodParticles.splice(index, 1);
            });
        }

        // Update the checkAnswer function to include food dropping
        function checkAnswer(selectedIndex) {
            const feedbackElement = document.getElementById('feedbackMessage');
            const closeButton = document.getElementById('closeModal');
            
            if (selectedIndex === currentQuestion.correct) {
                feedbackElement.innerHTML = '<span class="correct">Correct! Your muskrat is happy!</span>';
                
                // Drop food into the bowl
                createFallingFood();
                
                // Play eating animation if available
                if (actions['Eat'] || actions['Eating']) {
                    const eatAction = actions['Eat'] || actions['Eating'];
                    playAnimationAuto(eatAction.getClip().name);
                }
            } else {
                feedbackElement.innerHTML = '<span class="incorrect">Wrong answer. Try again next time!</span>';
            }
            
            // Disable answer buttons
            const buttons = document.querySelectorAll('.answer-button');
            buttons.forEach(button => button.disabled = true);
            
            // Show close button
            closeButton.style.display = 'inline-block';
            closeButton.onclick = () => {
                document.getElementById('questionModal').style.display = 'none';
                isQuestionActive = false;
                isFeedingActive = false;
            };
        }

        // Load the GLTF model
        const loader = new GLTFLoader();
        loader.load('./moskrat/Muskrat.gltf', (gltf) => {
            model = gltf.scene; // Store the model reference
            scene.add(model);

            // Debug: Log model info
            console.log('Model loaded:', model);
            console.log('Animations found:', gltf.animations.length);

            // Get model bounds and scale appropriately
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            console.log('Model size:', size);
            console.log('Model center:', center);

            // Center the model
            model.position.sub(center);
            model.position.y = 0; // Place on ground

            // Calculate camera distance based on model size
            const maxDimension = Math.max(size.x, size.y, size.z);

            // Much closer camera positioning - divide by 30 to get much closer (3x zoom)
            const cameraDistance = maxDimension / 30; // 3x closer than before!

            // Position camera to view the model properly AND see the skybox
            camera.position.set(cameraDistance * 2, cameraDistance * 1, cameraDistance * 3);
            camera.lookAt(0, 0, 0);

            // Make sure the camera can see the skybox
            camera.far = 15000; // Update far plane to see the skybox
            camera.updateProjectionMatrix();

            console.log('Model max dimension:', maxDimension);
            console.log('Camera distance:', cameraDistance);

            // Setup animations
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                
                const animationList = document.getElementById('animationList');
                
                gltf.animations.forEach((clip, index) => {
                    const action = mixer.clipAction(clip);
                    actions[clip.name] = action;
                    
                    // Create list item for each animation
                    const li = document.createElement('li');
                    li.textContent = clip.name;
                    li.addEventListener('click', () => playAnimation(clip.name, li));
                    animationList.appendChild(li);
                });

                console.log('Animation actions created:', Object.keys(actions));
            } else {
                console.log('No animations found in the model');
            }
        }, (progress) => {
            console.log('Loading progress:', progress);
        }, (error) => {
            console.error('Error loading GLTF model:', error);
        });

        // Add click event listener for the dog bowl only
        function onMouseClick(event) {
            // Convert mouse position to normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster from camera through mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // First check if we clicked on the dog bowl
            const bowlIntersects = raycaster.intersectObject(dogBowl, true);
            
            if (bowlIntersects.length > 0 && !isQuestionActive) {
                showFeedingQuestion();
                return; // Don't move if we clicked the bowl
            }
            
            // If not clicking on bowl, check for ground intersection for movement
            // Create a ground plane for raycasting
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0.5); // Y=0.5 (ground level)
            const intersectionPoint = new THREE.Vector3();
            
            // Calculate intersection with ground plane
            if (raycaster.ray.intersectPlane(groundPlane, intersectionPoint)) {
                // Check if the click point is within reasonable bounds
                const maxDistance = moveRadius;
                const clickDistance = Math.sqrt(intersectionPoint.x * intersectionPoint.x + intersectionPoint.z * intersectionPoint.z);
                
                if (clickDistance <= maxDistance) {
                    // Start movement to clicked position
                    startMovementToPosition(intersectionPoint);
                } else {
                    // If too far, move in that direction but limit distance
                    const direction = new THREE.Vector3(intersectionPoint.x, 0, intersectionPoint.z).normalize();
                    const limitedTarget = direction.multiplyScalar(maxDistance);
                    limitedTarget.y = 0;
                    startMovementToPosition(limitedTarget);
                }
            }
        }

        // Remove updateAnimationState function - replace with enhanced version with movement
        function updateAnimationState() {
            // Don't change animations if feeding is active or manual animation is playing
            if (isFeedingActive || isManualAnimationActive) {
                return;
            }
            
            const currentTime = Date.now();
            
            // Handle random movement
            if (!isMoving && currentTime > nextMoveTime) {
                // Start a random movement
                startRandomMovement();
            }
            
            if (isMoving) {
                // Continue moving towards target
                updateMovement();
                
                // Check if movement duration is over
                if (currentTime - moveStartTime > moveDuration) {
                    stopMovement();
                }
            } else {
                // Auto-play idle animation if no manual animation is active
                if (actions['Idle_A'] && currentAction !== actions['Idle_A']) {
                    playAnimationAuto('Idle_A');
                    idleStartTime = Date.now();
                    shouldFaceScreen = false;
                }
                
                // Check if we should start facing the screen
                if (currentAction === actions['Idle_A']) {
                    if (Date.now() - idleStartTime > idleFaceDelay && !shouldFaceScreen) {
                        shouldFaceScreen = true;
                    }
                }
            }
        }

        // Add new movement functions
        function startRandomMovement() {
            if (!model) return;
            
            // Generate random target position within radius
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * moveRadius;
            
            moveTarget.set(
                Math.cos(angle) * distance,
                model.position.y, // Keep same Y position
                Math.sin(angle) * distance
            );
            
            // Set movement parameters
            isMoving = true;
            moveStartTime = Date.now();
            moveDuration = 2000 + Math.random() * 3000; // 2-5 seconds of movement
            
            // Schedule next movement (5-15 seconds after this one ends)
            nextMoveTime = moveStartTime + moveDuration + 5000 + Math.random() * 10000;
            
            // Start walking animation if available
            const walkAction = actions['Walk'] || actions['Walking'] || actions['Run'] || actions['Running'];
            if (walkAction && currentAction !== walkAction) {
                playAnimationAuto(walkAction.getClip().name);
            }
            
            // Face movement direction
            shouldFaceScreen = false;
            
            console.log('Starting movement to:', moveTarget);
        }

        function updateMovement() {
            if (!model || !isMoving) return;
            
            // Calculate direction to target
            const direction = new THREE.Vector3();
            direction.subVectors(moveTarget, model.position);
            direction.y = 0; // Keep movement on ground plane
            
            const distance = direction.length();
            
            if (distance > 0.1) {
                // Normalize direction and apply speed
                direction.normalize();
                
                // Move towards target
                model.position.add(direction.multiplyScalar(moveSpeed));
                
                // Rotate to face movement direction
                const targetRotation = Math.atan2(direction.x, direction.z);
                model.rotation.y = targetRotation;
            } else {
                // Reached target
                stopMovement();
            }
        }

        function stopMovement() {
            isMoving = false;
            
            // Return to idle animation
            if (actions['Idle_A'] && currentAction !== actions['Idle_A']) {
                playAnimationAuto('Idle_A');
                idleStartTime = Date.now();
                shouldFaceScreen = false;
            }
            
            console.log('Movement stopped');
        }

        // Add new function to start movement to a specific position
        function startMovementToPosition(targetPosition) {
            if (!model) return;
            
            // Stop any current random movement
            isMoving = false;
            
            // Set new target
            moveTarget.copy(targetPosition);
            moveTarget.y = model.position.y; // Keep same Y position
            
            // Calculate distance to determine movement duration
            const distance = model.position.distanceTo(moveTarget);
            
            // Set movement parameters
            isMoving = true;
            moveStartTime = Date.now();
            moveDuration = (distance / moveSpeed) * 50; // Adjust duration based on distance
            
            // Schedule next random movement for later (give user control for a while)
            nextMoveTime = moveStartTime + moveDuration + 8000; // 8 seconds after movement ends
            
            // Start walking animation if available
            const walkAction = actions['Walk'] || actions['Walking'] || actions['Run'] || actions['Running'];
            if (walkAction && currentAction !== walkAction) {
                playAnimationAuto(walkAction.getClip().name);
            }
            
            // Face movement direction immediately
            if (distance > 0.1) {
                const direction = new THREE.Vector3();
                direction.subVectors(moveTarget, model.position);
                direction.y = 0;
                direction.normalize();
                
                const targetRotation = Math.atan2(direction.x, direction.z);
                model.rotation.y = targetRotation;
            }
            
            shouldFaceScreen = false;
            
            console.log('Starting movement to clicked position:', moveTarget);
        }

        // Remove updateModelRotation function - replace with enhanced version
        function updateModelRotation() {
            if (model && shouldFaceScreen && !isMoving) {
                // Smoothly rotate to face the screen (rotation y = 0)
                const currentRotation = model.rotation.y;
                const rotationDiff = -currentRotation; // Target is 0
                
                // Apply smooth rotation
                const rotSpeed = 0.02; // Slow rotation speed
                if (Math.abs(rotationDiff) > rotSpeed) {
                    model.rotation.y += Math.sign(rotationDiff) * rotSpeed;
                } else {
                    model.rotation.y = 0; // Snap to exact position when close enough
                }
            }
        }

        // Automatic animation function (doesn't update UI)
        function playAnimationAuto(animationName) {
            if (currentAction && actions[animationName]) {
                currentAction.fadeOut(0.2);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.2).play();
            }
        }

        // Animation control functions (manual control from UI)
        function playAnimation(animationName, listItem) {
            // Set manual animation flag to prevent auto-animations from overriding
            isManualAnimationActive = true;
            
            // Stop any current movement when manually controlling animations
            if (isMoving) {
                stopMovement();
            }
            
            if (currentAction) {
                currentAction.fadeOut(0.3);
            }
            
            currentAction = actions[animationName];
            if (currentAction) {
                currentAction.reset().fadeIn(0.3).play();
                
                // Update UI
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                listItem.classList.add('active');
                
                // Reset manual animation flag after the animation duration + fade time
                // Get animation duration and set timeout accordingly
                const animationDuration = currentAction.getClip().duration;
                setTimeout(() => {
                    isManualAnimationActive = false;
                }, (animationDuration + 0.3) * 1000); // Convert to milliseconds and add fade time
            }
        }

        // Control buttons
        document.getElementById('playPause').addEventListener('click', () => {
            if (currentAction) {
                if (currentAction.paused) {
                    currentAction.paused = false;
                    document.getElementById('playPause').textContent = 'Pause';
                } else {
                    currentAction.paused = true;
                    document.getElementById('playPause').textContent = 'Play';
                }
            }
        });

        document.getElementById('stop').addEventListener('click', () => {
            if (currentAction) {
                currentAction.stop();
                document.getElementById('playPause').textContent = 'Play';
                document.querySelectorAll('#animationList li').forEach(li => li.classList.remove('active'));
                
                // Reset manual animation flag when stopping
                isManualAnimationActive = false;
            }
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            
            // Update animation state
            updateAnimationState();
            
            // Update model rotation for screen facing
            updateModelRotation();
            
            // Update falling food animation
            updateFallingFood();
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Remove mouse move listener, keep only click listener for dog bowl interaction
        window.addEventListener('click', onMouseClick);

        // Also need to call createBeautifulGround() and loadDogBowl()
        // Add these function calls after the scene setup:
        createBeautifulGround();
        loadDogBowl();

        animate();
    </script>
</body>
</html>
